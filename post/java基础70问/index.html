<!doctype html>
<html lang="en-us">
  <head>
    <title>欢迎来到我的仓库</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://815090488.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java基础70问"/>
<meta name="twitter:description" content="标识符：字母、数字、下划线（_）、美元符号组成，数字不能开头
switch语句参数类型：int 、short、byte、char、string、枚举。
1.Java的八种基本类型？ Long、int、short、byte、double、float、char、boolean
基本数据类型自动转换 byte-&gt;short,char -&gt; int -&gt; long float -&gt; double int -&gt; float long -&gt; double 记住：小可转大，大转小会失去精度！！！  2.面向对象的三大特征？ 封装、继承、多态
3.引用类型有哪几种？ 引用类型有四种
强引用(StrongReference) 软引用(SoftReference) 弱引用(WeakReference) 虚引用(PhantomReference)  4.自动装箱和自动拆箱？ int Integer double Double float Float short Short byte Byte long Long  自动装箱：
自动装箱的作用就是将基本数据类型转换成对应的类的类型的对象
//在-128~127 之外的数 Integer i1 =200; Integer i2 =200; System.out.println(&quot;i1==i2: &quot;&#43;(i1==i2)); // 在-128~127 之内的数 Integer i3 =100; Integer i4 =100; System.out.println(&quot;i3==i4: &quot;&#43;(i3==i4)); 输出的结果是： i1==i2: false i3==i4: true equals() 比较的是两个对象的值（内容）是否相同。 &quot;==&quot; 比较的是两个对象的引用（内存地址）是否相同，也用来比较两个基本数据类型的变量值是否相等。  自动拆箱："/>

    <meta property="og:title" content="Java基础70问" />
<meta property="og:description" content="标识符：字母、数字、下划线（_）、美元符号组成，数字不能开头
switch语句参数类型：int 、short、byte、char、string、枚举。
1.Java的八种基本类型？ Long、int、short、byte、double、float、char、boolean
基本数据类型自动转换 byte-&gt;short,char -&gt; int -&gt; long float -&gt; double int -&gt; float long -&gt; double 记住：小可转大，大转小会失去精度！！！  2.面向对象的三大特征？ 封装、继承、多态
3.引用类型有哪几种？ 引用类型有四种
强引用(StrongReference) 软引用(SoftReference) 弱引用(WeakReference) 虚引用(PhantomReference)  4.自动装箱和自动拆箱？ int Integer double Double float Float short Short byte Byte long Long  自动装箱：
自动装箱的作用就是将基本数据类型转换成对应的类的类型的对象
//在-128~127 之外的数 Integer i1 =200; Integer i2 =200; System.out.println(&quot;i1==i2: &quot;&#43;(i1==i2)); // 在-128~127 之内的数 Integer i3 =100; Integer i4 =100; System.out.println(&quot;i3==i4: &quot;&#43;(i3==i4)); 输出的结果是： i1==i2: false i3==i4: true equals() 比较的是两个对象的值（内容）是否相同。 &quot;==&quot; 比较的是两个对象的引用（内存地址）是否相同，也用来比较两个基本数据类型的变量值是否相等。  自动拆箱：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://815090488.github.io/post/java%E5%9F%BA%E7%A1%8070%E9%97%AE/" />
<meta property="article:published_time" content="2019-07-30T20:39:46&#43;08:00"/>
<meta property="article:modified_time" content="2019-07-30T20:39:46&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="https://815090488.github.io/"><img style="box-shadow:0px 0px 50px -13px aqua;" class="app-header-avatar" src="/avatar.jpg"  /></a>
      <h3>Welcome to my repository of knowledge</h3>
      <p>欢迎来到我的知识仓库</p>
			<div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Java基础70问</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jul 30, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          7 min read
        </div></div>
    </header>
    <div class="post-content">
      

<p><strong>标识符：字母、数字、下划线（_）、美元符号组成，数字不能开头</strong></p>

<p><strong>switch语句参数类型</strong>：int 、short、byte、char、string、枚举。</p>

<h4 id="1-java的八种基本类型">1.Java的八种基本类型？</h4>

<p>Long、int、short、byte、double、float、char、boolean</p>

<p><img src="C:Users81509myblogcontentimagesv2-a4de2da2942089375382858919e3ae63_hd.png" alt="v2-a4de2da2942089375382858919e3ae63_hd" /></p>

<pre><code class="language-java">基本数据类型自动转换 
 byte-&gt;short,char -&gt; int -&gt; long       
 float -&gt; double 
 int -&gt; float 
 long -&gt; double   
 记住：小可转大，大转小会失去精度！！！
</code></pre>

<h4 id="2-面向对象的三大特征">2.面向对象的三大特征？</h4>

<p>封装、继承、多态</p>

<h4 id="3-引用类型有哪几种">3.引用类型有哪几种？</h4>

<p>引用类型有四种</p>

<pre><code class="language-java">强引用(StrongReference)
软引用(SoftReference)
弱引用(WeakReference)
虚引用(PhantomReference)
</code></pre>

<h4 id="4-自动装箱和自动拆箱">4.自动装箱和自动拆箱？</h4>

<pre><code class="language-java">int Integer
double Double
float Float
short Short
byte Byte
long Long
</code></pre>

<p><strong>自动装箱</strong>：</p>

<p>自动装箱的作用就是将基本数据类型转换成对应的类的类型的对象</p>

<pre><code class="language-java">//在-128~127 之外的数
 Integer i1 =200;  
 Integer i2 =200;          
 System.out.println(&quot;i1==i2: &quot;+(i1==i2));                 
 // 在-128~127 之内的数
 Integer i3 =100;  
 Integer i4 =100;  
 System.out.println(&quot;i3==i4: &quot;+(i3==i4));
 　　 输出的结果是：
    i1==i2: false
    i3==i4: true

equals() 比较的是两个对象的值（内容）是否相同。

&quot;==&quot; 比较的是两个对象的引用（内存地址）是否相同，也用来比较两个基本数据类型的变量值是否相等。
</code></pre>

<p><strong>自动拆箱</strong>：</p>

<p>自动拆箱的目的，就是要把原来的类的类型的对象转回成基本类型</p>

<pre><code class="language-java">1 Integer i = 10; //装箱
2  int t = i; //拆箱，实际上执行了 int t = i.intValue();
</code></pre>

<h4 id="5-jdk和jre关系">5.JDK和JRE关系？</h4>

<p><strong>JRE(Java Runtime Enviroment)</strong> 是 Java 的运行环境。面向 Java 程序的使用者，而不是开发者</p>

<p><strong>JDK</strong>(Java Development Kit) 又称 J2SDK(Java2 Software Development Kit)，是 <strong>Java 开发工具包</strong>，它提供了 Java 的开发环境。</p>

<p><strong>JVM是java虚拟机</strong></p>

<p><strong>JDK包含JRE，而JRE包 含JVM。</strong></p>

<h4 id="6-你所了解的ide有哪些">6.你所了解的IDE有哪些？</h4>

<pre><code>eclipse 
myeclipse
IntelliJ IDEA
</code></pre>

<h4 id="7-java开发及执行过程-用到哪些工具">7.Java开发及执行过程？用到哪些工具？</h4>

<h4 id="8-break和continue区别">8.break和continue区别？</h4>

<p><strong>1 break;</strong>
while循环break是用于永久终止循环。即不执行本次循环中break后面的语句，直接跳出循环。break可以用在switch语句中
<strong>2continue;</strong>
while循环continue是用于终止本次循环。即本次循环中continue后面的代码不执行，进行下一次循环的入口判断。</p>

<h4 id="9-循环有哪些-区别是什么">9.循环有哪些？区别是什么？</h4>

<p>for循环、while循环、do&hellip;while循环</p>

<p><strong>循环结构for语句的格式：</strong></p>

<p>　　for(初始化表达式;条件表达式;循环后的操作表达式) {</p>

<p>　　　　　循环体;</p>

<p>　　　}</p>

<p><strong>循环结构while语句的格式：</strong></p>

<p>　　初始化语句;</p>

<p>​    　　while(判断条件语句) {</p>

<p>　　　　　　循环体语句;</p>

<p>　　　　　　控制条件语句;</p>

<p>　　　}</p>

<p><strong>循环结构do&hellip;while语句的格式：</strong></p>

<p>　　初始化语句;</p>

<p>　　　　do {</p>

<p>　　　　　　循环体语句;</p>

<p>　　　　　　控制条件语句;</p>

<p>　　　　}while(判断条件语句);</p>

<p>总结:</p>

<p>三种循环语句的区别:</p>

<p>1.do&hellip;while循环至少执行一次循环体.　　</p>

<p>2.而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句</p>

<h4 id="10-解释你对封装的理解">10.解释你对封装的理解？</h4>

<p>封装就是将类的信息隐藏在类内部、不允许外部程序直接访问，而是通过该类的方法实现对隐藏信息的操作和访问。（get/set方法）</p>

<h4 id="11-解释下多态">11.解释下多态？</h4>

<ul>
<li><p>多态指的是对象的多种形态、</p></li>

<li><p>多态有两种：</p>

<ul>
<li>引用多态：父类的引用可以指向本类的对象；父类的引用可以指向子类的对象</li>
</ul>

<pre><code class="language-java">//父类
public class Animal{
    public String name;
    public int age;
    public void run(){
        System.out.println(&quot;动物都会跑&quot;)
    }
}
    
//子类
public class cat extends Animal{
        
}
    
public class Test{
    public static void main(String[] args){
        Animal animal = new Animal();
        Animal cat = new cat();
    }
}
</code></pre>

<ul>
<li>方法多态：创建父类对象时。调用的方法为父类方法；创建子类对象时，调用的方法是子类重写的方法或继承自父类的方法</li>
</ul>

<pre><code class="language-java">//父类
public class Animal{
    public String name;
    public int age;
    public void run(){
        System.out.println(&quot;动物都会跑&quot;)
    }
}
    
//子类
public class cat extends Animal{
    public void run(){
        System.out.println(&quot;动物都会跑&quot;)
    }
}
    
public class Test{
    public static void main(String[] args){
        Animal animal = new Animal();
        Animal cat = new cat();
        animal.run();
        cat.run();   
    }
}
</code></pre></li>

<li><p>继承是多态的实现基础</p></li>
</ul>

<h4 id="12-重写">12.重写？</h4>

<ul>
<li>两同：方法名和参数都相同</li>
<li>两小：

<ul>
<li>子类返回类型小于等于父类方法返回类型</li>
<li>子类抛出异常小于等于父类方法抛出异常</li>
</ul></li>
<li>一大：子类访问权限大于等于父类方法的访问权限</li>
<li>父类的成员方法只能被它的子类重写</li>
<li>声明为final的方法不能被重写</li>
<li>明为static的方法不能被重写，但是能够被再次声明。（static和final的都不能被重写）</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li>
<li>构造方法不能被重写。（构造方法属于static的）</li>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
</ul>

<h4 id="13-重载">13.重载？</h4>

<ul>
<li>方法名相同，但参数类型和个数可以不相同，返回值类型可以不相同</li>
<li>方法重载就是在类中创建多个方法，方法名相同，参数列表不同，调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法，体现多态性；</li>
<li>【构造方法的重载】：只需要看参数即可，如果想在一个构造方法中调用另一个构造方法，那么可以使用this()的方法调用，this()括号中的参数表示目标构造方法的参数，this()必须要作为构造方法的第一跳语句，换句话说，this()之前不能有任何可执行的代码。</li>
</ul>

<h4 id="14-构造方法">14.构造方法？</h4>

<ul>
<li><p>构造方法的名称必须与所属类的名称相同</p></li>

<li><p>构造方法没有返回数据，但是也不需要在定义中前置void</p></li>

<li><p>如果没有这个构造方法，系统会给予一个默认的构造方法，空构造</p></li>
</ul>

<h4 id="15-this作用及用法">15.this作用及用法？</h4>

<ul>
<li>this表示当前对象本身</li>
<li>this表示当前对象的引用</li>
<li>使用this调用重载的构造方法时必须在第一句</li>
<li>this不能用于static方法中</li>
</ul>

<h4 id="16-super关键字">16.super关键字？</h4>

<ul>
<li>调用父类的构造方法、先有继承，再有super关键字的使用。必须在子类的构造方法中对父类的构造方法进行调用，不能在子类的其他方法中、调用父类的构造方法的代码，必须写在子类构造方法的第一行。</li>
<li>调用父类的属性和一般方法、调用的是子类中覆写的、super.属性; // 调用父类的属性、super.方法();// 调用父类的方法</li>
</ul>

<h4 id="17-抽象类特点">17.抽象类特点？</h4>

<ul>
<li>抽象方法一定定义在抽象类中。抽象类中可以不定义抽象方法</li>
<li>抽象方法和抽象类都必须被abstract关键字修饰</li>
<li>抽象类不可以用new创建对象，因为调用抽象方法没意义</li>
<li><em>抽象类中的方法要被使用，必须由子类复写其所有的抽象方法后，建立子类对象调用。</em></li>
<li>如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。</li>
</ul>

<h4 id="18-接口的特点-jdk8后有什么新特性">18.接口的特点？JDK8后有什么新特性？</h4>

<ul>
<li>接口使用interface修饰</li>
<li>接口是常量和抽象方法的集合

<ul>
<li>常量：默认使用public static final 修饰</li>
<li>方法：默认使用public abstract修饰</li>
</ul></li>
<li>在JDK1.8以后，接口还加入了了默认方法和静态方法</li>
<li>接口不能实例化 ，不能new对象</li>
<li>接口的实现类方法

<ul>
<li>如果一个类想要实现一个接口就必须实现接口中定义的所有抽象方法</li>
<li>如果一个类不想实现接口中的抽象方法，就将实现类升级为接口</li>
</ul></li>
</ul>

<h4 id="19-final-finalize和finally">19.final,finalize和finally</h4>

<ul>
<li><strong>final关键字</strong>

<ul>
<li>定义变量，包括静态的和非静态的</li>
<li>定义方法的参数</li>
<li>定义方法</li>
<li>定义类</li>
<li>final修饰的基本类型是不可改变的</li>
</ul></li>
<li>被final修饰的变量必须被初始化：

<ul>
<li>在定义的时候初始化</li>
<li>final变量可以在初始化块中初始化，但不可以在静态初始化块中初始化</li>
<li>静态final变量可以在静态初始化块中初始化，不可以在初始化块中初始化</li>
<li>final变量还可以在类的构造方法中初始化，但是静态final变量不可以</li>
</ul></li>
</ul>

<p><strong><em>finally语句</em></strong></p>

<p>只能用在try/catch语句中，并且附带着一个语句块，表示这段语句最终总是被执行</p>

<p><strong><em>finalize方法</em></strong></p>

<p>finalize，它是一个方法，属于java.lang.Object类，finalize()方法是GC（garbage collector）运行机制的一部分</p>

<h4 id="20-throw和throws区别">20.throw和throws区别？</h4>

<ul>
<li><p>throw是语句抛出一个异常，一般会用于程序出现某种逻辑时程序员主动抛出某种特定类型的异常</p></li>

<li><p>throws是方法可能抛出异常的声明，当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理</p></li>

<li><p>throws出现在方法函数头；而throw出现在函数体。</p></li>

<li><p>throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。</p></li>
</ul>

<h4 id="21-非运行时异常和运行时异常区别">21.非运行时异常和运行时异常区别？</h4>

<p>异常表示程序运行过程中可出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求声明跑出未被捕获的运行时异常。</p>

<h4 id="22-静态块和非静态块-构造方法关系">22.静态块和非静态块，构造方法关系</h4>

<p>执行顺序：</p>

<p>1. 没有继承的执行顺序
   - 实现自身的静态属性和静态代码块。
   - 实现自身的非静态属性和非静态代码块。
   - 执行自身的构造函数。
2. 继承时的执行顺序
   - 实现父类的公共静态属性和静态块级代码。
   - 实现自身的静态属性和静态块级代码。
   - 实现父类的非静态属性和非静态代码块。
   - 执行父类的构造函数。
   - 实现自身的非静态属性和非静态代码块。
   - 执行自身的构造函数。</p>

<h4 id="23-非静态内部类引用外部类对象的方式">23.非静态内部类引用外部类对象的方式？</h4>

<p>方式</p>

<ul>
<li>外部类访问内部类：必须建立内部类的对象</li>
<li>内部类访问外部类：内部类可以直接访问外部类的成员包括私有成员，因为外部类持有内部类的引用</li>
</ul>

<p>特例：内部类写在外部类的方法中(即局部变量的位置)</p>

<p>　　1、内部来外部类均可定义变量/常量</p>

<p>　　2、只能被final/abstract修饰</p>

<p>　　3、只能访问被final/abstract修饰的变量</p>

<p>　　4、可以直接访问外部类中的成员，因为还持有外部类的引用</p>

<h4 id="24-java为什么可以跨平台">24.Java为什么可以跨平台？</h4>

<p>JAVA程序不是直接在电脑上运行的，是在虚拟机上进行的，每个系统平台都是有自己的虚拟机（JVM），所以JAVA语言能跨平台。</p>

<ul>
<li>java代码不是直接运行在CPU上，而是运行在java虚机（简称JVM)上的。</li>

<li><p>java是先把java文件编译成二进制字节码的class文件，jvm就解释执行class文件。</p></li>

<li><p>就是因为java是运行在jvm上的，所以它的代码就能不经修改，就能在不同平台的jvm上运行(在linux上用linux的jvm，在windows上用windows的jvm）</p></li>
</ul>

<h4 id="25-类加载器有什么用">25.类加载器有什么用？</h4>

<p><strong>JVM默认有三个类加载器（Java Classloader）</strong>：</p>

<ul>
<li>引导类加载器（bootstrap class loader），不继承自java.lang.ClassLoader，负责加载核心Java库，存储在<JAVA_HOME>/jre/lib目录中</li>
<li>扩展类加载器（Extensions class loader）</li>
<li>系统类加载器（system class loader），可以通过ClassLoader.getSystemClassLoader()来获取</li>
<li>每个类装载器有一个父装载器（parent class loader）</li>
</ul>

<pre><code class="language-java">public class ClassLoaderTree { 

    public static void main(String[] args) { 
        ClassLoader loader = ClassLoaderTree.class.getClassLoader(); 
        while (loader != null) { 
            System.out.println(loader.toString()); 
            loader = loader.getParent(); 
        } 
    } 
 }
</code></pre>

<p>作用：加载class文件</p>

<h4 id="26-collection和collections区别和关系">26.Collection和Collections区别和关系</h4>

<ul>
<li><p>Collection是集合类的上级的接口，，继承与他的接口主要有Set和List。</p></li>

<li><p>Collections是针对集合类别的一个工具类，，他提供一系列静态方法对各种集合的搜索，排序，线程安全化等操作。此类不能实例化</p></li>
</ul>

<h4 id="27-集合类中的迭代器-iterator-是什么-作用">27.集合类中的迭代器（Iterator）是什么？作用？</h4>

<ul>
<li>迭代器：是一种设计模式，提供了一种方法，来对集合，容器进行遍历的方式，不需要关注底层数据结构和数据类型，来达到底层和上层遍历解耦的目的。</li>
<li>集合要具有iterator 方法需要实现iterable接口，要自定义一个迭代器内部类，类需要实现Iterator接口；</li>
</ul>

<h4 id="28-list接口-set接口和map接口的区别">28.List接口、Set接口和Map接口的区别？</h4>

<ul>
<li><strong>List和Set接口自Collection（数组对象）接口，而Map不是继承的Collection接口</strong></li>
</ul>

<p><strong>List接口</strong>：(元素的插入是<strong>有序</strong>的（存入和取出的顺序一致），每个元素都有索引（角标），<strong>允许容器中的元素有重复</strong>。可以有null元素)</p>

<ul>
<li><strong>ArrayList:</strong>

<ul>
<li>针对数组包装</li>
<li>非线程安全，性能更高</li>
</ul></li>
<li><strong>LinkedList:</strong>底层基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢</li>
<li><strong>Vector:</strong>线程安全，性能相对较低</li>
<li>基于Array的List（Vector，ArrayList）适合查询，而LinkedList（链表）适合添加，删除操作;</li>
</ul>

<p><strong>Set接口</strong>：( 不允许容器中的元素有重复。这个是List和Set最大的区别。元素是无序的（但是有可能有序）)、(Set接口有两个实现类：HashSet(底层由HashMap实现)，LinkedHashSet )</p>

<ul>
<li><strong>HashSet</strong>（底层是HashMap）

<ul>
<li>HashSet不存重复数据，如果是自定义java类，应该覆写hashCode和equals两个方法，先判断hashCode再判断equals，自定义规则。开发工具自动生成</li>
</ul></li>
<li><strong>TreeSet</strong>(SortedSet接口有一个实现类：TreeSet（底层由平衡二叉树实现）)

<ul>
<li>TreeSet也不存重复数据并且可以排序，判断对象是否相同以及排序依靠的是比较器比较</li>
<li>TreeSet不依靠hashCode和equals方法。使用TreeSet保存的java类需要实现Comparable接口，不然运行时报错。</li>
</ul></li>
<li><strong>LinkedHashSet :</strong> 具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。</li>
</ul>

<p><strong>Map接口</strong>：(键值对方式出现)</p>

<ul>
<li><strong>HashMap</strong>

<ul>
<li>线程不安全，高效，支持null</li>
</ul></li>
<li><strong>HashTable</strong>

<ul>
<li>线程安全、低效，不支持null</li>
</ul></li>
<li><strong>LinkeHashMap</strong></li>
</ul>

<h4 id="29-进程和线程">29.进程和线程</h4>

<ul>
<li>进程：系统中正在运行的一个应用程序；程序一旦运行就是进程，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。</li>
<li>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。</li>
<li>进程——资源分配的最小单位，线程——程序执行的最小单位。</li>
</ul>

<p><strong>进程和线程的区别</strong>：</p>

<ul>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</li>
<li>处理机分给线程，即真正在处理机上运行的是线程。</li>
<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li>
</ul>

<h4 id="30-hashcode和equals在hashset中有什么作用">30.hashCode和equals在HashSet中有什么作用?</h4>

<p>首先我们熟知HashSet集合中元素存储的特点：</p>

<p>1）不允许元素重复；</p>

<p>2）不会记录元素添加的先后顺序；</p>

<p>3）HashSet中比较两个对象是否相同，要使用equals()方法，不能使用 ==；</p>

<p>4）底层依然使用哈希表（散列）算法，其本质就是数组形式，采用此算法就为提高查询的效率；</p>

<p>5）插入速度也比较快，但适合于少量元素插入操作；一旦所存储元素个数满足（size * loadFoctor &gt; size），哈希表就要扩容，此时操作速度极慢，性能就会降低！</p>

<ul>
<li>1）先判断两个对象的hashCode()方法返回值是否相同，即存储的位置；</li>
<li>2）然后再判断两个对象的equals()方法返回值是否为true，即存储实际的对象值</li>
<li>哈希码不同时，则必为不同的对象，重写hashCode()方法时，哈希码相同（可能出现重码现象），则根据euqals()方法判断是否新值覆盖旧值</li>
</ul>

<h4 id="31-arraylist和linkedlist区别">31.ArrayList和LinkedList区别？</h4>

<ul>
<li>ArrayList 和Vector是采用数组方式存储数据的,是根据索引来访问元素的，索引数据快插入数据慢</li>
<li>LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，插入数度较快</li>
</ul>

<h4 id="32-hashset和hashmap有关系么">32.HashSet和HashMap有关系么？</h4>

<ul>
<li><p>HashSet底层实际上是(key,value)类型的HashMap,而我们知道,HashSet的key是不能重复的,所以HashSet的值自然也是没有重复的.因为HashMap的key可以为null,所以HashSet的值可以为null</p></li>

<li><p>HashSet在存储对象等数据时,为了去重,一般都会重写hashCode()和equals().</p>

<ul>
<li><p>equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。</p></li>

<li><p>hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的。</p></li>
</ul></li>
</ul>

<h4 id="33-arraylist的动态增长机制是什么">33.ArrayList的动态增长机制是什么？</h4>

<ul>
<li>ArrayList底层采用Object类型的数组实现，当使用不带参数的构造方法生成ArrayList对象时， 实际上会在底层生成一个长度为10的Object类型数组。

<ul>
<li>首先，ArrayList定义了一个私有的未被序列化的数组elementData，用来存储ArrayList的对象列表（注意只定义未初始）：private transient Object[] elementData;</li>
<li>其次，以指定初始容量（Capacity）或把指定的Collection转换为引用型数组后实例化elementData数组；如果没有指定，则预置初始容量为10进行实例化。把私有数组预先实例化，然后通过copyOf方法覆盖原数组，是实现自动改变ArrayList的大小(size)的关键</li>
</ul></li>
</ul>

<h4 id="34-在实例化对象时-是先执行的构造方法还是属性">34.在实例化对象时，是先执行的构造方法还是属性?</h4>

<p>先执行属性在执行构造方法</p>

<pre><code class="language-jav">下面以person对象为例进行解释：

Person person = new Person();

1.因为new用到了Person.class，所以会先找到Person.class文件并加载到内存中（由虚拟机完成）；

2.执行该类中的static代码块，（如果有的话），给Person.class类进行初始化；

3.在堆内存中开辟内存空间，分配内存地址；

4.在堆内存中建立对象的特有属性，并进行默认初始化。

5.对属性进行显示初始化；

6.对对象进行构造代码块初始化；

7.对对象进行对应的构造函数初始化；

8.将内存地址赋给栈内存中的变量。
</code></pre>

<h4 id="35-解释下你对java反射的认识">35.解释下你对Java反射的认识？</h4>

<ul>
<li><p>反射机制就是在程序的运行过程中被允许对程序本身进行操作，比如自我检查，进行装载，还可以获取类本身，类的所有成员变量和方法，类的对象，还可以在运行过程中动态的创建类的实例，通过实例来调用类的方法</p></li>

<li><p>利用反射机制可以获取类对象（也就是我们前面介绍的类对象，获取类对象之后我们便获取了类的模板，可以对类进行一些操作），有以下三种方法：</p></li>
</ul>

<p>1.类名.class()</p>

<p>2.对象名.getClass()</p>

<p>3.Class.forName(具体的类名)</p>

<pre><code class="language-jav">  //1.类名.class
  		
  		Class clz = User.class;
  		System.out.println(clz);
  		
  		//2.对象名.getClass()
  		
  		Class clz1 = new User().getClass();	
  		System.out.println(clz==clz1);
  		
  		//3.Class.forName()
  		
  		//Class clz2 = Class.forName(&quot;User&quot;);
  		Class clz2 = Class.forName(&quot;cn.itcast_01.User&quot;);
  		System.out.println(clz==clz2);
</code></pre>

<pre><code class="language-txt">  反射 (Reflection) 是 Java 的特征之一，它允许运行中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。
  反射的核心是JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。
  
  Java 反射主要提供以下功能：
  在运行时判断任意一个对象所属的类；
  在运行时构造任意一个类的对象；
  在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；
  在运行时调用任意一个对象的方法
  重点：是运行时而不是编译时
  
  反射的基本运用
  1、获得 Class 对象
  方法有三种：
  (1) 使用 Class 类的 forName 静态方法:Class.forName(driver);
  (2)直接获取某一个对象的 class，比如Class&lt;?&gt; klass = int.class;
  Class&lt;?&gt; classInt = Integer.TYPE;
  (3)调用某个对象的 getClass() 方法，比如:StringBuilder str = new StringBuilder(&quot;123&quot;);
  Class&lt;?&gt; klass = str.getClass();
  2、判断是否为某个类的实例
  一般地，我们用 instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 isInstance() 方法来判断是否为某个类的实例，它是一个 native 方法：public native boolean isInstance(Object obj);
  3.创建实例
  通过反射来生成对象主要有两种方式。
  使用Class对象的newInstance()方法来创建Class对象对应类的实例。
  先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。
  4.获取方法
  获取某个Class对象的方法集合，主要有以下几个方法：
  getDeclaredMethods 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。
  getMethods 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。
  getMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。
  5、获取构造器信息
  获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例
  6、获取类的成员变量（字段）信息
  主要是这几个方法，在此不再赘述：
  getFiled：访问公有的成员变量
  getDeclaredField：所有已声明的成员变量，但不能得到其父类的成员变量
  getFileds 和 getDeclaredFields 方法用法同上（参照 Method）。
  7.调用方法
  当我们从类中获取了一个方法后，我们就可以用 invoke() 方法来调用这个方法
  8.用反射创建数组
  数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference.
  Array类为java.lang.reflect.Array类。我们通过Array.newInstance()创建数组对象.
  
</code></pre>

<h4 id="36-怎么理解string的不可变性">36.怎么理解String的不可变性？</h4>

<ul>
<li><p>String实现依靠的是char[]</p></li>

<li><p>在程序内部这个数组被声明为private的，同时是个final的。</p></li>

<li><p>Private可以保证value数组不被调用者访问到，final可以确保数组的地址是不变的。</p></li>

<li><p>声明数组为final的时仅仅可以保证数组的地址是不变的，并不能保证数组里面的值不变。</p></li>

<li><p>总结：内部的value数组被声明为private，确保了value的值不会被外部程序改变。</p></li>

<li><h5 id="string类被声明为final的-它的意义是什么呢">String类被声明为final的，它的意义是什么呢？</h5>

<ul>
<li>类被声明为final的时候，这个类是不可以为继承的，这样就不能修改这个类里面的方法实现。</li>
<li>String的不可变性确保了线程安全。在并发场景下，对共享资源的写操作会引发静态条件，只有对资源进行写操作才引发资源状态的不一致，而不可变对象不可写，因此是线程安全的。</li>
</ul></li>

<li><h5 id="string不可变的原因">String不可变的原因：</h5>

<ul>
<li>（1） 类设计为final的，确保类不被继承，方法不被覆盖</li>
<li>（2） 内部实现上用的是private final的数组</li>
</ul></li>

<li><p><strong>内部实现上避免改变原字符串：</strong></p></li>

<li><p>（1） 任何对String的写操作都不是在原来的字符串上进行的修改，而是创建的新对象</p></li>

<li><p><strong>好处</strong>：</p>

<ul>
<li>（1） 线程安全</li>
<li>（2） 在使用String作为HashMap和HashSet的key时，可以确保键值唯一性</li>
</ul></li>
</ul>

<h4 id="37-stringbuffer和stringbuilder区别">37.StringBuffer和StringBuilder区别？</h4>

<ul>
<li>StringBuffer和StringBuilder类都表示内容可以被修饰的字符串，StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在线程不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。</li>
</ul>

<h4 id="38-vector和arraylist区别">38.Vector和ArrayList区别？</h4>

<p>List接口下一共实现了三个类：ArrayList，Vector，LinkedList。LinkedList就不多说了，它一般主要用在保持数据的插入顺序的时候。ArrayList和Vector都是用数组实现的，主要有这么三个区别</p>

<ul>
<li>1、Vector是多线程安全的，而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；</li>
<li>2、两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同的，很多网友说Vector增加原来空间的一倍，ArrayList增加原来空间的50%，其实也差不多是这个意思，不过还有一点点问题可以从源码中看出，一会儿从源码中分析。</li>
<li>3、Vector可以设置增长因子，而ArrayList不可以</li>
</ul>

<h4 id="39-hashmap和hashtable区别">39.HashMap和Hashtable区别？</h4>

<ul>
<li>HashMap和Hashtable都实现了Map 接口</li>
<li>HashMap是非synchronized的，而Hashtable是synchronized的。这说明Hashtable是线程安全的，而且多个线程可以共享一个Hashtable；</li>
<li>而HashMap如果没有正确的同步的话，是不能被多个线程所共享的。但是，Java 5中为我们提供了ConcurrentHashMap，它是Hashtable的替代，而且比Hashtable的扩展性更好。</li>
<li>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null值（HashMap可以存在null的键值(key)和值(value),但是Hashtable是不可以的)。</li>
<li>HashMap不能保证随着时间的推移Map中的元素次序是不变的。要保持元素顺序不变，除非是LinkedHashMap。</li>
</ul>

<h4 id="40-使用一层循环如何实现九九乘法表-写出代码">40.使用一层循环如何实现九九乘法表？写出代码</h4>

<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        //循环控制实现输出九行
        for (int i = 0, j = 0; i &lt; 10; j++) {
            System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + i * j + &quot;\t&quot;);
            if (i == j) {
                System.out.println();
                j = 0;
                i++;
            }
        }
    }
}
</code></pre>

<h4 id="41-序列化和反序列化的概念">41. 序列化和反序列化的概念？</h4>

<ul>
<li>序列化：把对象转换为字节序列的过程称为对象的序列化。</li>
<li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化。</li>
<li>实现Serializable接口</li>
</ul>

<p><strong>好处</strong>：</p>

<ul>
<li>利用序列化实现远程的通信，即在网络上传输信息。</li>
<li>可以实现数据的持久化，通过序列化可以把数据永久的保存到硬盘上。</li>
</ul>

<h4 id="42-基本流和包装流区别">42.基本流和包装流区别？</h4>

<h4 id="43-字节流和字符流区别-哪一个流没有关闭和清空时-不会写入文件内容">43.字节流和字符流区别？哪一个流没有关闭和清空时，不会写入文件内容？</h4>

<p>Java中字节流与字符流的区别</p>

<p>1、定义</p>

<ul>
<li>字节流是一种执行8位字节输入和输出的机制，基本单元为字节；而字符流是Java中执行16位Unicode输入和输出操作的机制，基本单元为Unicode码元。</li>
</ul>

<p>2、结尾</p>

<ul>
<li>字节流以stream结尾；而，字符流以reader和writer结尾</li>
</ul>

<p>3、处理方式</p>

<ul>
<li>字节流是最基本的，采用ASCII编码；它通常用于处理二进制数据，它是按字节来处理的，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元。</li>
<li>字符流采用Unicode编码，它是按虚拟机的encode来处理，也就是要进行字符集的转化；它通常处理文本数据，它支持写入及读取Unicode码元。</li>
</ul>

<p>4、缓冲区</p>

<ul>
<li>字节流默认不使用缓冲区；字符流使用缓冲区。</li>
</ul>

<h4 id="44-datainputstream有什么特点-什么优势">44.DataInputStream有什么特点？什么优势?</h4>

<p>特点：</p>

<p>数据输入流允许应用程序以与机器无关方式从底层输入流中读取基本Java数据类型。</p>

<p>下面的构造方法用来创建数据输入流对象。</p>

<pre><code>DataInputStream dis = new DataInputStream（InputStream in）;
</code></pre>

<p>另一种创建方式是接收一个字节数组，和两个整形变量off，len，off表示第一个读取的字节，len表示读取字节的长度。</p>

<p>序号    方法描述<br />
  1     public final int read（byte [] r，int off，int len）抛出IOException 从所包含的输入流中将len个字节读入一个字节数组中。如果len为-1，则返回已读字节数。
  2     public final int read（byte [] b）抛出IOException 从所包含的输入流中读取一定数量的字节，并将它们存储到缓冲区数组b中。
  3     public final Boolean readBooolean（）抛出IOException，<strong>public final byte readByte（）抛出IOException，public final short readShort（）抛出IOExceptionpublic final Int readInt（）抛出IOException</strong>从输入流中读取字节，返回输入流中两个字节作为对应的基本数据类型返回值。
  4     public String readLine（）抛出IOException 从输入流中读取下一文本行。</p>

<h4 id="45-为防止忘记手动关闭流-可以使用什么结构来创建流">45.为防止忘记手动关闭流，可以使用什么结构来创建流？</h4>

<h4 id="46-接口比抽象类的优势在哪里">46.接口比抽象类的优势在哪里？</h4>

<ul>
<li>1、接口中的所有方法都是抽象方法，可以为用户提供模板</li>
<li>2.接口可以多实现，但是抽象类智能单继承</li>
</ul>

<h4 id="47-xml和html区别">47.XML和HTML区别？</h4>

<p>什么是XML、HTML？
   XML:可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。</p>

<p>HTML:超文本标记语言,就是指页面内可以包 含图片、链接，甚至音乐、程序等非文字元素。超文本标记语言的结构包括“头”部分（英语：Head）、和“主体”部分（英语：Body）， 其中“头”部提供关于网页的信息，“主体”部分提供网页的具体内容。</p>

<p>不同之处：</p>

<p>语法有所不同。XML语法比较严谨而HTML语法比较松散。
用途不同。XML主要用于数据格式化存储而HTML主要用于网页的编辑。</p>

<p>区别：</p>

<p>html是一种基本的web网页设计语言，xhtml是一个基于XML的置标语言。</p>

<p>最主要的不同:</p>

<p>XHTML元素必须正确的被嵌套，元素必须关闭，标签必须小写，必须有根元素。</p>

<h4 id="48-xml解析可以有哪几种">48.XML解析可以有哪几种？</h4>

<p>1.DOM解析： DOM的全称是Document Object Model，也即文档对象模型。在应用程序中，基于DOM的XML分析器将一个XML文档转换成一个对象模型的集合（通常称DOM树），应用程序正是通过对这个对象模型的操作，来实现对XML文档数据的操作。通过DOM接口，应用程序可以在任何时候访问XML文档中的任何一部分数据，因此，这种利用DOM接口的机制也被称作随机访问机制。</p>

<p>2.SAX解析：SAX的全称是Simple APIs for XML，也即XML简单应用程序接口。与DOM不同，SAX提供的访问模式是一种顺序模式，这是一种快速读写XML数据的方式。当使用SAX分析器对XML文档进行分析时，会触发一系列事件，并激活相应的事件处理函数，应用程序通过这些事件处理函数实现对XML文档的访问，因而SAX接口也被称作事件驱动接口。</p>

<p>3.JDOM解析：JDOM采用了Java中的Collection架构来封装集合，是Java爱好者更加熟悉的模式</p>

<p>4.DOM4J解析：xml解析器一次性把整个xml文档加载进内存，然后在内存中构建一颗Document的对象树，通过Document对象，得到树上的节点对象，通过节点对象访问（操作）到xml文档的内容…</p>

<h4 id="49-switch语句中的表达式类型可以是哪几种">49.switch语句中的表达式类型可以是哪几种？</h4>

<p><strong>switch语句参数类型</strong>：int 、short、byte、char、string、枚举。</p>

<h4 id="50-接口是可以继承及多继承">50.接口是可以继承及多继承？</h4>

<p>java中只有单继承</p>

<h4 id="51-static关键字">51.static关键字</h4>

<p>1、静态变量（属于class本身，跟具体的实例没有关系，只会随着jvm退出而退出）
2、静态方法（比如常用的工具类，可以直接调用而不用具体的实例）
3、静态代码块（比如static｛｝，跟直接的静态变量类似，同一个变量出现在多个静态代码块，最终结果以最后一次的结果为准）
4、静态内部类（可以实现外部共享静态内部类，静态内部类与外部无关，可以理解为一个单独的静态类，独立的静态资源。外部类.内部类方便引用和提高可读性）</p>

<p>5、静态导入（比如类上部分的import ***，可以具体到某个包*包含所有）</p>

<h4 id="52-垃圾回收器启动时间及手动关闭方法">52.垃圾回收器启动时间及手动关闭方法？</h4>

<h4 id="53-在使用try-catch有多个catch时-要注意什么问题">53.在使用try-catch有多个catch时，要注意什么问题？</h4>

<ul>
<li>当使用多个 catch 语句捕获多个异常时， Java 规定捕获 Exception 的 catch 语句必须排在最后</li>
<li>父类在子类之后</li>
</ul>

<h4 id="54-什么是守护线程-有什么特点">54.什么是守护线程？有什么特点？</h4>

<ul>
<li>1.<strong>守护线程</strong>（例如垃圾回收线程：<strong>gc线程</strong>）</li>
<li>2.<strong>非守护线程</strong>（用户线程：<strong>用户线程</strong>即我们手动创建的线程）</li>
<li><strong>守护线程与非守护线程的区别</strong>

<ul>
<li>1.<strong>守护线程</strong>
有一个特征，例如当<strong>主线程</strong>运行的时候，<strong>垃圾回收线程</strong>一起运行。
当<strong>主线程</strong>销毁，会和<strong>主线程</strong>一起销毁。</li>
<li>2.<strong>非守护线程</strong>
如果<strong>主线程</strong>销毁，<strong>用户线程</strong>继续运行且互不影响。</li>
</ul></li>
<li><strong>当主线程销毁停止，非守护线程（用户线程）并没有结束，而是一直在执行，与主线程互不影响。</strong></li>
</ul>

<h4 id="55-sleep和wait的区别">55.sleep和wait的区别？</h4>

<ul>
<li>sleep()是Thread类中的方法，而wait（）是Object类中的方法</li>
<li>调用sleep（）执行时，线程不会释放对象锁，而wait()会释放对象锁，只有针对notify（）方法或者notifyAll()之后线程才进入对象锁定池准备</li>
<li>sleep可以在任何地方使用，而wait只能在同步方法或者同步块中使用</li>
<li>sleep需要捕获异常，而wait()不需要捕获异常</li>
<li>sleep是静态方法，wait是实例方法</li>
</ul>

<h4 id="56-和-区别">56.&amp;和&amp;&amp;区别？</h4>

<ul>
<li>&amp;是运算符，&amp;&amp;是逻辑运算符</li>
<li>&amp;&amp;还有短路功能，只要一边表达式为false，则另一边不会再进行比较</li>
<li>&amp;也可以比较，但是他比较两边，而且他是位运算，如果两边都不是Boolean类型的数据则按位与运算。

<ul>
<li>比如：两个字节：如果相对应位都是1，则结果为1，否则为0</li>
</ul></li>
</ul>

<h4 id="57-比较器compareable-和-comparator的区别">57.比较器Compareable 和 Comparator的区别？</h4>

<ul>
<li><p>Comparable和Comparator都是实现集合中元素的比较，排序的两种比较器接口，</p></li>

<li><p>Comparable是在集合内部定义的实现的排序，称为内比较器，</p></li>

<li><p>Comparator是在集合外部实现排序，称为外比较器如果想实现排序，就需要在集合外定义Comparator接口的方法或者集合内实现Compaarable接口的方法</p></li>

<li><p><strong>Comparable 自然排序</strong></p></li>
</ul>

<p>Comparable 是排序接口。</p>

<p>若一个类实现了Comparable接口，就意味着“<strong>该类支持排序</strong>”。 即然实现Comparable接口的类支持排序，假设现在存在“实现Comparable接口的类的对象的List列表(或数组)”，则该List列表(或数组)可以通过 Collections.sort（或 Arrays.sort）进行排序。</p>

<p>此外，“实现Comparable接口的类的对象”可以用作“有序映射(如TreeMap)”中的键或“有序集合(TreeSet)”中的元素，而不需要指定比较器</p>

<p><strong>Comparable 定义</strong></p>

<p>Comparable 接口仅仅只包括一个函数，它的定义如下</p>

<pre><code class="language-java">  package java.lang;
  import java.util.*;
  
  public interface Comparable&lt;T&gt; {
      public int compareTo(T o);
  }123456
</code></pre>

<p>Comparable 可以让实现它的类的对象进行比较，具体的比较规则是按照 compareTo 方法中的规则进行。这种顺序称为 <strong>自然顺序</strong>。</p>

<p>compareTo 方法的返回值有三种情况：</p>

<ul>
<li>e1.compareTo(e2) &gt; 0 即 e1 &gt; e2</li>
<li>e1.compareTo(e2) = 0 即 e1 = e2</li>
<li>e1.compareTo(e2) &lt; 0 即 e1 &lt; e2</li>
</ul>

<p>注意：</p>

<blockquote>
<p>1.由于 null 不是一个类，也不是一个对象，因此在重写 compareTo 方法时应该注意 e.compareTo(null) 的情况，即使 e.equals(null) 返回 false，compareTo 方法也应该主动抛出一个空指针异常 NullPointerException。</p>

<p>2.Comparable 实现类重写 compareTo 方法时一般要求 e1.compareTo(e2) == 0 的结果要和 e1.equals(e2) 一致。这样将来使用 SortedSet 等<strong>根据类的自然排序进行排序</strong>的集合容器时可以保证保存的数据的顺序和想象中一致。</p>
</blockquote>

<ul>
<li><p><strong>Comparator定制排序</strong></p></li>

<li><p>Comparator 则是在外部制定排序规则，然后作为排序策略参数传递给某些类，比如 Collections.sort(), Arrays.sort(), 或者一些内部有序的集合（比如 SortedSet，SortedMap 等）。</p></li>
</ul>

<p>使用方式主要分三步：</p>

<ul>
<li>创建一个 Comparator 接口的实现类，并赋值给一个对象</li>
<li>在 compare 方法中针对自定义类写排序规则</li>
<li>将 Comparator 对象作为参数传递给 排序类的某个方法</li>
<li>向排序类中添加 compare 方法中使用的自定义类</li>
</ul>

<pre><code class="language-java">    // 1.创建一个实现 Comparator 接口的对象
          Comparator comparator = new Comparator() {
              @Override
              public int compare(Object object1, Object object2) {
                  if (object1 instanceof NewBookBean &amp;&amp; object2 instanceof NewBookBean){
                      NewBookBean newBookBean = (NewBookBean) object1;
                      NewBookBean newBookBean1 = (NewBookBean) object2;
                      //具体比较方法参照 自然排序的 compareTo 方法，这里只举个栗子
                      return newBookBean.getCount() - newBookBean1.getCount();
                  }
                  return 0;
              }
          };
  
          //2.将此对象作为形参传递给 TreeSet 的构造器中
          TreeSet treeSet = new TreeSet(comparator);
  
          //3.向 TreeSet 中添加 步骤 1 中 compare 方法中设计的类的对象
          treeSet.add(new NewBookBean(&quot;A&quot;,34));
          treeSet.add(new NewBookBean(&quot;S&quot;,1));
          treeSet.add( new NewBookBean(&quot;V&quot;,46));
          treeSet.add( new NewBookBean(&quot;Q&quot;,26));
</code></pre>

<h4 id="58-内存泄漏和内存溢出区别">58.内存泄漏和内存溢出区别?</h4>

<ul>
<li><p>内存泄露：程序在申请内存后，无法释放已经申请的内存，就会出现内存泄露</p></li>

<li><p>内存溢出：指程序在申请内存时,没有足够的内存空间供其使用，就会出现内存溢出</p></li>
</ul>

<h4 id="59-如何实现对象克隆">59.如何实现对象克隆？</h4>

<ul>
<li>1). 实现Cloneable接口并重写Object类中的clone()方法；</li>
<li>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</li>
</ul>

<h4 id="60-克隆中深拷贝和浅拷贝分别有什么区别">60.克隆中深拷贝和浅拷贝分别有什么区别？</h4>

<ul>
<li>1.浅克隆：只复制基本类型的数据，引用类型的数据只复制了引用的地址，引用的对象并没有复制，在新的对象中修改引用类型的数据会影响原对象中的引用。</li>
<li>2.深克隆：是在引用类型的类中也实现了clone，是clone的嵌套，复制后的对象与原对象之间完全不会影响。</li>
<li>3.使用序列化也能完成深复制的功能：对象序列化后写入流中，此时也就不存在引用什么的概念了，再从流中读取，生成新的对象，新对象和原对象之间也是完全互不影响的。</li>
<li>4.使用clone实现的深克隆其实是浅克隆中嵌套了浅克隆，与toString方法类似</li>
</ul>

<h4 id="61-jdbc的使用步骤">61.JDBC的使用步骤？</h4>

<ul>
<li><p>加载jdbc驱动</p></li>

<li><p>通过java.lang.Class类的静态方法forName（String className）实现</p></li>

<li><pre><code class="language-java">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
</code></pre>

<ul>
<li><p>提供JDBC连接的URL</p></li>

<li><pre><code class="language-java">Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/music&quot;, &quot;用户名&quot;, &quot;密码&quot;);
</code></pre></li>
</ul></li>

<li><p>创建连接</p></li>

<li><pre><code class="language-java">PreparedStatement ps = conn.prepareStatement(sql);
</code></pre>

<ul>
<li><p>执行sql</p></li>

<li><pre><code>有三种方式：
executeQuery： 返回一个结果集，查询
executeUpdate：  返回int 用于插入，修改，删除
execute  ： 返回多个结果集
ResultSet rs = ps.executeQuery();
</code></pre></li>
</ul></li>

<li><p>处理结果</p></li>

<li><pre><code class="language-java">while(rs.next()){   
  
  String name = rs.getString(&quot;name&quot;) ;   
  
  String pass = rs.getString(1) ; // 此方法比较高效   
 }   
</code></pre>

<ul>
<li>关闭JDBC对象</li>
</ul>

<h4 id="62-连接池是什么-有什么优点">62.连接池是什么，有什么优点？</h4>

<p>1.1 连接池概述
连接池就是一次性创建多个连接，将多个连接缓存在内存中 ，形成数据库连接池，如果应用程序需要操作数据库，只需要从连接池中获取一个连接，使用后，并不需要关闭连接，只需要将连接放回到连接池中。</p>

<p>1.2 连接池的优点
节省创建连接与释放连接性能消耗；</p>

<p>连接池中连接起到复用的作用，提高程序性能。</p>

<h4 id="63-什么是事务">63.什么是事务？</h4>

<p>事务：是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）；</p>

<p>事务的属性</p>

<p>事务属性的种类：   传播行为、隔离级别、只读和事务超时</p>

<p>a)   传播行为定义了被调用方法的事务边界。</p>

<p>传播行为</p>

<p>意义</p>

<p>PROPERGATION_MANDATORY</p>

<p>表示方法必须运行在一个事务中，如果当前事务不存在，就抛出异常</p>

<p>PROPAGATION_NESTED</p>

<p>表示如果当前事务存在，则方法应该运行在一个嵌套事务中。否则，它看起来和 PROPAGATION_REQUIRED 看起来没什么俩样</p>

<p>PROPAGATION_NEVER</p>

<p>表示方法不能运行在一个事务中，否则抛出异常</p>

<p>PROPAGATION_NOT_SUPPORTED</p>

<p>表示方法不能运行在一个事务中，如果当前存在一个事务，则该方法将被挂起</p>

<p>PROPAGATION_REQUIRED</p>

<p>表示当前方法必须运行在一个事务中，如果当前存在一个事务，那么该方法运行在这个事务中，否则，将创建一个新的事务</p>

<p>PROPAGATION_REQUIRES_NEW</p>

<p>表示当前方法必须运行在自己的事务中，如果当前存在一个事务，那么这个事务将在该方法运行期间被挂起</p>

<p>PROPAGATION_SUPPORTS</p>

<p>表示当前方法不需要运行在一个是事务中，但如果有一个事务已经存在，该方法也可以运行在这个事务中</p>

<p>b)   隔离级别</p>

<p>在操作数据时可能带来 3 个副作用，分别是<strong>脏读、不可重复读、幻读</strong>。为了避免这 3 中副作用的发生，在标准的 SQL 语句中定义了 4 种隔离级别，分别是未提交读、已提交读、可重复读、可序列化。而在 spring 事务中提供了 5 种隔离级别来对应在 SQL 中定义的 4 种隔离级别，如下：</p>

<p>隔离级别</p>

<p>意义</p>

<p>ISOLATION_DEFAULT</p>

<p>使用后端数据库默认的隔离级别</p>

<p>ISOLATION_READ_UNCOMMITTED</p>

<p>允许读取未提交的数据（对应未提交读），可能导致脏读、不可重复读、幻读</p>

<p>ISOLATION_READ_COMMITTED</p>

<p>允许在一个事务中读取另一个已经提交的事务中的数据（对应已提交读）。可以避免脏读，但是无法避免不可重复读和幻读</p>

<p>ISOLATION_REPEATABLE_READ</p>

<p>一个事务不可能更新由另一个事务修改但尚未提交（回滚）的数据（对应可重复读）。可以避免脏读和不可重复读，但无法避免幻读</p>

<p>ISOLATION_SERIALIZABLE</p>

<p>这种隔离级别是所有的事务都在一个执行队列中，依次顺序执行，而不是并行（对应可序列化）。可以避免脏读、不可重复读、幻读。但是这种隔离级别效率很低，因此，除非必须，否则不建议使用。</p>

<p>c)    只读</p>

<p>如果在一个事务中所有关于数据库的操作都是只读的，也就是说，这些操作只读取数据库中的数据，而并不更新数据，那么应将事务设为只读模式（ READ_ONLY_MARKER ） , 这样更有利于数据库进行优化 。</p>

<p>因为只读的优化措施是事务启动后由数据库实施的，因此，只有将那些具有可能启动新事务的传播行为 (PROPAGATION_NESTED 、 PROPAGATION_REQUIRED 、 PROPAGATION_REQUIRED_NEW) 的方法的事务标记成只读才有意义。</p>

<p>如果使用 Hibernate 作为持久化机制，那么将事务标记为只读后，会将 Hibernate 的 flush 模式设置为 FULSH_NEVER, 以告诉 Hibernate 避免和数据库之间进行不必要的同步，并将所有更新延迟到事务结束。</p>

<p>d)   事务超时</p>

<p>如果一个事务长时间运行，这时为了尽量避免浪费系统资源，应为这个事务设置一个有效时间，使其等待数秒后自动回滚。与设</p>

<p>置“只读”属性一样，事务有效属性也需要给那些具有可能启动新事物的传播行为的方法的事务标记成只读才有意义</p>

<h4 id="64-事务的特征">64.事务的特征？</h4>

<ul>
<li>1 、原子性
事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做</li>
<li>2 、一致性
事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。</li>
<li>3 、隔离性
一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>4 、持续性
也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</li>
</ul>

<h4 id="65-java中包括哪四种引用">65.Java中包括哪四种引用？</h4>

<ul>
<li>强引用：
当我们使用new创建对象时，被创建的对象就是强引用，如Object object = new Object()，其中的object就是一个强引用了。如果一个对象具有强引用，JVM就不会去GC它，JVM宁可会报OOM来终止程序，也不回收该对象。</li>
<li>软引用:
如果一个对象只具备软引用，如果内存空间足够，那么JVM就不会GC它，如果内存空间不足了，就会GC该对象。</li>
<li>弱引用:
如果一个对象只具有弱引用，只要JVM的GC线程检测到了，就会立即回收。弱引用的生命周期要比软引用短很多。不过，如果垃圾回收器是一个优先级很低的线程，也不一定会很快就会释放掉软引用的内存。</li>
<li>虚引用：
如果一个对象只具有虚引用，那么它就和没有任何引用一样，随时会被JVM当作垃圾进行GC。</li>
</ul>

<h4 id="66-谈谈你对类加载器的理解">66.谈谈你对类加载器的理解？</h4>

<ul>
<li>https 协议需要到 ca 申请证书，目前市面上的免费证书也不少，收费的也都比较贵。</li>
<li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li>
<li>http 的连接很简单，是无状态的；H</li>
</ul>

<h4 id="67-java中native关键字作用">67.java中native关键字作用？</h4>

<ul>
<li><p>native关键字在java开发过程中是使用不到的，native关键字是与c++联合开发时使用，他是一个java调用其他接口的一个声明关键字</p></li>

<li><p>Java&mdash;&mdash;&gt;JNI&mdash;&ndash;&gt;c++/c</p></li>

<li><p>java&lt;&mdash;&mdash;JNI&lt;&mdash;&mdash;-c++/c</p></li>

<li><p>native不能与abstract同用，因为native表示这些方法是有实现体的而abstract没有实现体，那么两者矛盾，肯定不能一起使用</p></li>
</ul>

<h4 id="68-transient关键字的作用">68.transient关键字的作用？</h4>

<ul>
<li>一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。</li>
<li>java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中</li>
</ul>

<h4 id="69-volatile关键字的作用">69.volatile关键字的作用？</h4>

<ul>
<li>volatile关键字是JVM提供的一种<strong>轻量级</strong>的同步机制</li>
<li><strong>作用</strong></li>
<li>可见性：即一个线程修改了公共数据，新值对于其他线程来说是可以立即得知的。</li>
<li>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li>
<li>有序性：程序执行的顺序按照代码的先后顺序执行。</li>
<li><strong>volatile关键字能禁止指令重排序</strong></li>
<li>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>
<li>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</li>
</ul>

<h4 id="70-什么是jni">70.什么是JNI?</h4>

<ul>
<li>JNI(Java Native Interface)这是一个本机编程的接口，它也是java jdk（开发工具包）的一部分，JNI可以支持java中使用其他语言，java要调用其他语言的接口，需要经过他处理。java所谓的跨平台，在一定程度上放弃了底层操作，因为不同的硬件或者操作系统底层的操作都是不一样的。</li>
</ul>

<h4 id="71-tcp和udp的区别-三次握手和四次挥手">71.TCP和UDP的区别，三次握手和四次挥手？</h4>

<table>
<thead>
<tr>
<th>tcp</th>
<th>udp</th>
</tr>
</thead>

<tbody>
<tr>
<td>面向连接</td>
<td>面向无连接</td>
</tr>

<tr>
<td>传输速度慢</td>
<td>传输速度快</td>
</tr>

<tr>
<td>传输可靠</td>
<td>传输不可靠（容易丢包）</td>
</tr>

<tr>
<td>面向字节流</td>
<td>面向报文</td>
</tr>

<tr>
<td>一般传输数据采用</td>
<td>可以用于长视频（对可靠性要求不高的场景）</td>
</tr>
</tbody>
</table>

<p><strong>TCP的优点</strong>： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有<strong>三次握手</strong>来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</p>

<p><strong>TCP的缺点</strong>： <strong>慢，效率低，占用系统资源高</strong>，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</p>

<p><strong>UDP的优点</strong>： <strong>快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制</strong>，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击……</p>

<p><strong>UDP的缺点</strong>： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包</p>

<ul>
<li><strong>为什么要三次握手？</strong></li>
<li>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收机能正常。</li>
<li><strong>第一次握手,client:你准备好了吗?</strong></li>
<li><strong>第二次握手,server: 我准备好了,你呢?</strong></li>
<li><strong>第三次握手,client: 我也准备好了.我们开始吧!</strong></li>
<li>核心思想就是,客户端和服务器分别确认对方是否准备好建立连接,并且每一次的确认信息都要得到对方的回应,两次确认和两次回应本应该是四次,但是第二次握手时,服务器将发出的确认信息和对客户端的回应做成一条信息发送了,所以就是三次握手.</li>
<li>为什么要四次挥手？</li>
<li>根本原因是，一方发送FIN只表示自己发完了所有要发的数据，但还允许对方继续把没发完的数据发过来。</li>
<li><strong>第一次挥手,client:我说完了</strong></li>
<li><strong>第二次挥手,server:我知道了(但此时server可能还有话要说)</strong></li>
<li><strong>第三次挥手,server:我也说完了</strong></li>
<li><strong>第四次挥手,client:我知道了,(双方挂了电话)</strong></li>
</ul>

<h4 id="72-常见的网络协议有">72.常见的网络协议有？</h4>

<ul>
<li><p><strong>TCP/IP协议、UDP协议、HTTP协议、FTP协议、Telnet协议、SMTP协议、NFS协议等。</strong></p></li>

<li><p><strong>TCP/IP 协议</strong></p></li>

<li><p>传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。</p></li>

<li><p><strong>IP</strong></p></li>

<li><p>IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层&mdash;TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）</p></li>

<li><h3 id="tcp">TCP</h3></li>
</ul>

<p>TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。</p>

<ul>
<li><p><strong>UDP 协议</strong></p></li>

<li><p>UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</p></li>

<li><p><strong>FTP 协议</strong></p></li>

<li><p>FTP协议：文件传输协议。</p></li>

<li><p><strong>Telnet 协议</strong></p></li>

<li><p>Telnet协议（远程登录），是 TCP/IP 协议族中应用最广泛的协议，是Internet远程登录服务的标准协议和主要方式。Telnet协议的目的是提供一个相对通用的，双向的，面向八位字节的通信方法，允许界面终端设备和面向终端的过程能通过一个标准过程进行互相交互。应用Telnet协议能够把本地用户所使用的计算机变成远程主机系统的一个终端。</p></li>

<li><p>SMTP 协议</p></li>

<li><p>SMTP协议：简单邮件传输协议，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。</p></li>

<li><p>NFS协议</p></li>

<li><p>NFS，即网络文件系统，是一种用于文件共享的协议，允许一个系统在网络上与它人共享目录和文件。通过使用NFS，用户和程序可以像访问本地文件一样访问远端系统上的文件。</p></li>
</ul>

<h4 id="73-cookie和session">73.cookie和session</h4>

<ul>
<li><p>session是一个会话链接机制，其实是一种临时cookie可以让浏览器和服务器交互，断开后不能重新建立</p></li>

<li><p>cookie数据保存在客户端，session数据保存在服务端，考虑到安全使用seesion</p></li>

<li><p>session会在一定时间内保存在服务器上，当访问增多，会比较占用服务器性能，考虑到减轻服务器性能方面,应当使用cookie.</p></li>
</ul>

<h4 id="74-for循环和foreach循环">74.for循环和foreach循环</h4>

<p>foreach循环是for循环的加强版，foreach循环效率比for循环效率高</p>

<h4 id="75-创建对象的四种方法">75.创建对象的四种方法</h4>

<ul>
<li>new</li>
<li>反序列化</li>
<li>反射</li>
<li>克隆</li>
</ul>

<h4 id="76-jvm模型">76.JVM模型</h4>

<p>JVM模型一般分为4大部分</p>

<p><img src="C:Users81509myblogcontentimagesJVM模型.jpg" alt="JVM模型" /></p>

<ul>
<li><p><strong>类加载器（ClassLoader）</strong></p></li>

<li><p>在JVM启动或运行时加载需要的class文件到JVM中</p></li>

<li><p><strong>内存区（也叫运行时数据区）</strong></p></li>

<li><p>JVM运行的时候所分配的区域，内存区可以划分为以下几个部分：</p></li>

<li><p>a、方法区</p></li>
</ul>

<p>用于存放类结构等信息的地方，主要包括常量池、静态变量、构造函数等；</p>

<ul>
<li><p>b、Java栈</p>

<pre><code>  Java栈总是与线程关联在一起，每创建一个线程时，就会为这个线程创建一个对应的java栈，每运行一个方法就会创建一个栈帧，用于存放对应的局部变量、操作栈和方法返回值等。每一个方法从调用到完成的过程，就对应一个栈帧在Java栈中的入栈与出栈的过程；所有Java栈是线程所私有的；
</code></pre></li>

<li><p>c、Java堆</p>

<pre><code>  存储Java实例和对象的地方；这里是GC的主要运作区域；Java栈和Java堆都是被所有线程共享的；

  GC的两种算法：引用计数法、可达性算法；
</code></pre></li>

<li><p>d、本地线程栈</p>

<pre><code>  和Java栈的作用差不都，只不过是为了JVM调用本地方法服务的；
</code></pre></li>

<li><p>e、程序计数器</p>

<pre><code>  用于保存当前线程执行的内存地址；由于JVM是多线程的（多个线程轮流切换），为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，来记录之前中断的地方，因此程序计数器也是线程私有的；
</code></pre></li>

<li><p><strong>3、执行引擎</strong></p></li>
</ul>

<p>​         执行class文件中的字节码指令；</p>

<ul>
<li><strong>4、本地库</strong></li>
</ul>

<p>​         主要调用C或者C++实现的本地方法及返回结果；</p>

<h4 id="77-面向对象七大原则">77、面向对象七大原则？</h4>

<ol>
<li><strong>单一职责原则</strong>（Single Responsibility Principle）</li>
</ol>

<p>每一个类应该专注于做一件事情。</p>

<ol>
<li><strong>里氏替换原则</strong>（Liskov Substitution Principle）</li>
</ol>

<p>超类存在的地方，子类是可以替换的。</p>

<ol>
<li><strong>依赖倒置原则</strong>（Dependence Inversion Principle）</li>
</ol>

<p>实现尽量依赖抽象，不依赖具体实现。</p>

<ol>
<li><strong>接口隔离原则（</strong>Interface Segregation Principle）</li>
</ol>

<p>应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。</p>

<ol>
<li><strong>迪米特法则</strong>（Law Of Demeter）</li>
</ol>

<p>又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。</p>

<ol>
<li><strong>开闭原则</strong>（Open Close Principle）</li>
</ol>

<p>面向扩展开放，面向修改关闭。</p>

<ol>
<li><strong>组合/聚合复用原则</strong>（Composite/Aggregate Reuse Principle CARP）</li>
</ol>

<p>尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。</p>

<h4 id="78-jsp的九大内置对象和四大作用域和两个跳转">78、jsp的九大内置对象和四大作用域和两个跳转</h4>

<ul>
<li><strong>jsp九大内置对象</strong></li>
<li>request：request内置对象，提供cookie，header，session内数据方法</li>
<li>response：用于响应客户请求</li>
<li>page：page对象指jsp当前页面本身</li>
<li>session：会话对象，存储本次会话的有关信息</li>
<li>application：应用级别对象，对于网站所有用户而言，用于用户之间的数据共享</li>
<li>out：用于输出到HTML页面上</li>
<li>exception：exception内置对象是用来处理页面异常错误</li>
<li>config：config内置对象是ServletConfig类的实例，用来传递初始化信息</li>
<li>pageContext：它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象</li>
<li><strong>四大作用域</strong></li>
<li>page:只对当前页面有效</li>
<li>request：再一次请求中有效，通过服务器跳转变量存在，但如果通过客户端跳转，变量消失</li>
<li>session：再一次会话中有效，在页面跳转，跳转到新页面，变量都不会消失，如果关闭浏览器重新打开，则视为一次新的会话，变量消失。</li>
<li>application：应用级别作用域，客户端的任何行为都不会使该变量消失，除非服务器主动清除变量或者服务器重启</li>
<li>作用范围page&lt;request&lt;session&lt;application</li>
<li><strong>两个跳转</strong></li>
<li>客户端跳转</li>
<li>服务端跳转</li>
</ul>

<h4 id="79-事务产生的原因">79、事务产生的原因？</h4>

<p>脏读:读取了未提交的新事物，然后被回滚了
事务级别:T1读取,T1修改,T2读取,T1回滚,T2就是脏读
不可重复读:读已提交,读取了提交的新事物，指更新操作
锁字段:T1读取,T2读取 T2修改 T1再次读取就是不可重复的
幻读:也是读取了提交的新事物，指增删操作行级别:T1读取,T2添加或删除,T1读取,出现幻读</p>

<h4 id="80-线程池">80、线程池</h4>

<ul>
<li><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务</p></li>

<li><p><strong>线程池的组成部分</strong>
1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；</p></li>
</ul>

<p>4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。</p>

<h4 id="81-线程之间转化">81、线程之间转化？</h4></li>
</ul>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>

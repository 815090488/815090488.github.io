<!doctype html>
<html lang="en-us">
  <head>
    <title>欢迎来到我的仓库</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://815090488.giithub.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Spring注解驱动开发"/>
<meta name="twitter:description" content="Spring注解驱动开发 1、@Configuration 配置类的配置文件注解（写一个配置类）
2、@Bean 给容器注册一个Bean ;类型为返回值，id默认是使用方法名作为id,自定义使用value=“ ”自定义
&lt;bean id=&quot;person&quot; class=&quot;com.atguigu.bean.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;19&quot;/&gt; &lt;/bean&gt;  @ComponentScan(value = &quot;com.atguigu&quot;, includeFilters = { @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {MyTypeFilter.class}) },useDefaultFilters = false) public class MainConfig { //给容器中注册一个bean；类型为返回值的类型；id默认是使用方法名作为id，也可以使用value进行指定 @Bean(value = &quot;person001&quot;) public Person person(){ return new Person(&quot;李四&quot;,13); } }  3、@ComponentScan @ComponentScan(value = &quot;com.atguigu&quot;)value指定要扫描的包  @ComponentScan扫描包相当于xml文件中的
&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; //use-default-filters=&quot;false&quot;禁用掉默认的过滤规则，才能使用includeFilters //includeFilters只扫描的包，是一个数组  @ComponentScan(value = &quot;com.atguigu&quot;,excludeFilters = { @ComponentScan."/>

    <meta property="og:title" content="Spring注解驱动开发" />
<meta property="og:description" content="Spring注解驱动开发 1、@Configuration 配置类的配置文件注解（写一个配置类）
2、@Bean 给容器注册一个Bean ;类型为返回值，id默认是使用方法名作为id,自定义使用value=“ ”自定义
&lt;bean id=&quot;person&quot; class=&quot;com.atguigu.bean.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;19&quot;/&gt; &lt;/bean&gt;  @ComponentScan(value = &quot;com.atguigu&quot;, includeFilters = { @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {MyTypeFilter.class}) },useDefaultFilters = false) public class MainConfig { //给容器中注册一个bean；类型为返回值的类型；id默认是使用方法名作为id，也可以使用value进行指定 @Bean(value = &quot;person001&quot;) public Person person(){ return new Person(&quot;李四&quot;,13); } }  3、@ComponentScan @ComponentScan(value = &quot;com.atguigu&quot;)value指定要扫描的包  @ComponentScan扫描包相当于xml文件中的
&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; //use-default-filters=&quot;false&quot;禁用掉默认的过滤规则，才能使用includeFilters //includeFilters只扫描的包，是一个数组  @ComponentScan(value = &quot;com.atguigu&quot;,excludeFilters = { @ComponentScan." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://815090488.giithub.io/post/spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/" />
<meta property="article:published_time" content="2019-06-24T16:02:10&#43;08:00"/>
<meta property="article:modified_time" content="2019-06-24T16:02:10&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="https://815090488.giithub.io/"><img style="box-shadow:0px 0px 50px -13px aqua;" class="app-header-avatar" src="/avatar.jpg"  /></a>
      <h3>Welcome to my repository of knowledge</h3>
      <p>欢迎来到我的知识仓库</p>
			<div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Spring注解驱动开发</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jun 24, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          5 min read
        </div></div>
    </header>
    <div class="post-content">
      

<h2 id="spring注解驱动开发">Spring注解驱动开发</h2>

<h5 id="1-configuration">1、@Configuration</h5>

<p>配置类的配置文件注解（写一个配置类）</p>

<h5 id="2-bean">2、@Bean</h5>

<p>给容器注册一个Bean ;类型为返回值，id默认是使用方法名作为id,自定义使用value=“ ”自定义</p>

<pre><code class="language-xml">&lt;bean id=&quot;person&quot; class=&quot;com.atguigu.bean.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
        &lt;property name=&quot;age&quot; value=&quot;19&quot;/&gt;
&lt;/bean&gt;
</code></pre>

<pre><code class="language-java">@ComponentScan(value = &quot;com.atguigu&quot;,
        includeFilters = {
        @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {MyTypeFilter.class})
        },useDefaultFilters = false)
public class MainConfig {
    //给容器中注册一个bean；类型为返回值的类型；id默认是使用方法名作为id，也可以使用value进行指定
    @Bean(value = &quot;person001&quot;)
    public Person person(){
        return new Person(&quot;李四&quot;,13);
    }
}
</code></pre>

<h5 id="3-componentscan">3、@ComponentScan</h5>

<pre><code class="language-java">@ComponentScan(value = &quot;com.atguigu&quot;)value指定要扫描的包
</code></pre>

<p>@ComponentScan扫描包相当于xml文件中的</p>

<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt;
        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
&lt;/context:component-scan&gt;
//use-default-filters=&quot;false&quot;禁用掉默认的过滤规则，才能使用includeFilters
//includeFilters只扫描的包，是一个数组

</code></pre>

<pre><code class="language-java">@ComponentScan(value = &quot;com.atguigu&quot;,excludeFilters = {
        @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class, Service.class})
})
//type = FilterType.ANNOTATION是使用注解的类型进行配置
//excludeFilters不扫描的包，是一个数组，classes也是一个数组
</code></pre>

<pre><code class="language-java">@ComponentScan(value = &quot;com.atguigu&quot;,
        includeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class})
},useDefaultFilters = false)

//use-default-filters=&quot;false&quot;禁用掉默认的过滤规则，才能使用includeFilters
//includeFilters只扫描的包，是一个数组
</code></pre>

<pre><code class="language-java">@ComponentScan(value = &quot;com.atguigu&quot;,
        includeFilters = {
        @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class}),
        @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,classes = {BookService.class})
        },useDefaultFilters = false)
//FilterType.ANNOTATION按照注解
//FilterType.ASSIGNABLE_TYPE按照指定的类型
//FilterType.ASPECTJ;使用ASPECTJ表达式
//FilterType.REGEX;使用正则表达式
//FilterType.CUSTOM;使用自定义规则
</code></pre>

<pre><code class="language-java">////FilterType.CUSTOM;使用自定义规则

public class MyTypeFilter implements TypeFilter {

    //metadataReader读取到当前正在扫描的类的信息
    //metadataReaderFactory;可以获取到其他任何类的信息
    @Override
    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
        //获取当前类注解的信息
        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();
        //获取当前正在扫描的类的类的信息
        ClassMetadata classMetadata = metadataReader.getClassMetadata();
        //获取当前类的资源（类的路径）
        Resource resource =metadataReader.getResource();


        String className = classMetadata.getClassName();
        System.out.println(&quot;------&gt;&quot;+className);
        if (className.contains(&quot;er&quot;)){return true;}
        return false;
    }
}
</code></pre>

<p>配置文件类</p>

<pre><code class="language-java">@ComponentScan(value = &quot;com.atguigu&quot;,
        includeFilters = {
        @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {MyTypeFilter.class})
        },useDefaultFilters = false)
public class MainConfig {
</code></pre>

<h5 id="4-scope调节作用域">4、@Scope调节作用域</h5>

<pre><code class="language-java">/**
 * prototype;多实例的:ioc容器启动并不会去调用方法创建对象放在容器中，每次获取的时候才会调用方法创建对象
 * singleton;单实例的（默认值）,ioc容器启动会调用方法创建对象放到ioc容器中,以后每次获取都是直接从容器(map.get())中拿
 * request 同一次请求创建一个实例
 * session 同一个session创建一个实例
 * @return
 */
@Lazy //设置懒加载
@Scope(&quot;prototype&quot;)
//默认是单实例的
@Bean
public Person person(){
    return new Person(&quot;kk&quot;,55);
}
</code></pre>

<p>相当于配置文件中</p>

<pre><code class="language-xml">&lt;bean id=&quot;person&quot; class=&quot;com.atguigu.bean.Person&quot; scope=&quot;prototype&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;kk&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;55&quot;/&gt;
&lt;/bean&gt;
</code></pre>

<h5 id="5-lazy-设置懒加载">5、@Lazy 设置懒加载</h5>

<pre><code class="language-txt">懒加载：
*          单实例bean；默认在容器启动的时候创建对象
*          懒加载：容器启动不创建对象，第一次使用（获取）bean创建对象，并初始化
</code></pre>

<h5 id="6-获取操作系统代码spring">6、获取操作系统代码spring</h5>

<pre><code class="language-java">public void test03(){
    AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MainConfig02.class);

    //获取操作系统
    ConfigurableEnvironment environment = annotationConfigApplicationContext.getEnvironment();
    String property = environment.getProperty(&quot;os.name&quot;);
    System.out.println(property);
</code></pre>

<h5 id="7-conditional-condition-按照一定的条件进行判断-满足条件给容器中注册bean">7、@Conditional（{Condition}）按照一定的条件进行判断，满足条件给容器中注册bean</h5>

<pre><code class="language-java">/**
 * @Conditional 按照一定的条件进行判断，满足条件给容器中注册bean
 *如果系统是win放Bill
 * 如果系统是linux放linus
 * @return
 */
@Conditional({WindowsCondition.class})
@Bean(&quot;bill&quot;)
public Person person01(){
    return new Person(&quot;Bill Gates&quot;,62);
}

@Conditional({LinuxCondition.class})
@Bean(&quot;linus&quot;)
public Person person02(){
    return new Person(&quot;linus&quot;,48);
}
</code></pre>

<pre><code class="language-java">//满足当前条件，这个类中配置的所有bean注册才会起作用
@Conditional({WindowsCondition.class})
@Configuration
public class MainConfig02 {}
</code></pre>

<p>写两个判断条件{Condition}类</p>

<pre><code class="language-java">public class WindowsCondition implements Condition {
    @Override
    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
        Environment environment = conditionContext.getEnvironment();
        String property = environment.getProperty(&quot;os.name&quot;);
        if(property.contains(&quot;Windows&quot;)){
            return  true;
        }
        return false;
    }
}
</code></pre>

<pre><code class="language-java">public class LinuxCondition implements Condition {

    /**
     *
     * @param conditionContext  判断条件能使用的上下文
     * @param annotatedTypeMetadata 注释信息
     * @return
     */
    @Override
    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
        //是否Linux系统
        //1、能获取到ioc使用的BeanFactory
        ConfigurableListableBeanFactory beanFactory = conditionContext.getBeanFactory();
        //2、获取类加载器
        ClassLoader classLoader = conditionContext.getClassLoader();
        //3、获取当前环境信息
        Environment environment = conditionContext.getEnvironment();
        //4、获取到bean定义的注册类
        BeanDefinitionRegistry registry = conditionContext.getRegistry();

        String property = environment.getProperty(&quot;os.name&quot;);
        if(property.contains(&quot;linux&quot;)){
            return true;
        }
        return false;
    }
}
</code></pre>

<p>测试</p>

<pre><code class="language-java">@Test
public void test03(){
    AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MainConfig02.class);

    //获取操作系统
    ConfigurableEnvironment environment = annotationConfigApplicationContext.getEnvironment();
    String property = environment.getProperty(&quot;os.name&quot;);
    System.out.println(property);


    String[] beanNamesForType = annotationConfigApplicationContext.getBeanNamesForType(Person.class);
    for (String names : beanNamesForType) {
        System.out.println(names);
    }
    Map&lt;String, Person&gt; beansOfType = annotationConfigApplicationContext.getBeansOfType(Person.class);
    System.out.println(beansOfType);
}
</code></pre>

<h5 id="8-import-导包">8、@Import 导包</h5>

<pre><code class="language-txt">/**
 * 给容器中注册组件
 * 1、包扫描（@Controller/@Service/@Repository/@Component）
 * 2、@Bean {导入的第三方包里面的组件}
 * 3、@Import 快速的给容器中导入一个组件
 *    3.1@Import(导入到容器中的组件，容器中就会自动注册这个组件，id默认是全类名)
 *    3.2ImportSelector:返回需要导入的组件的全类名数组
 *    3.3ImportBeanDefinitionRegistrar：手动注册bean到容器中
 * 4、使用Spring提供的FactoryBean（工厂bean）
 *     4.1默认获取到的工厂bean调用getObject创建的对象
 *     4.2要获取工厂bean本身，我们需要给id前面加一个&amp;
 *          &amp;colorFactoryBean
 */
</code></pre>

<p>3.1实例</p>

<pre><code class="language-java">@Import({Color.class, Red.class})
public class MainConfig02 {}
</code></pre>

<p>3.2实例</p>

<pre><code class="language-java">//自定义逻辑返回需要导入的组件
public class MyImportSelector implements ImportSelector {
    //返回值，就是导入到容器中的组件全类名
    @Override
    public String[] selectImports(AnnotationMetadata annotationMetadata) {
        return new String[]{&quot;com.atguigu.bean.Yellow&quot;,&quot;com.atguigu.bean.Blue&quot;};
    }
}
</code></pre>

<pre><code class="language-java">@Import({Color.class, Red.class,MyImportSelector.class})
public class MainConfig02 {}
</code></pre>

<p>3.3实例</p>

<pre><code class="language-java">@Import({MyImportBeanDefinitionRegistrar.class})
public class MainConfig02 {}
</code></pre>

<pre><code class="language-java">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {

    /**
     * @param annotationMetadata  ：当前类的注解信息
     * @param beanDefinitionRegistry ：BeanDefinition注册类
     *                               把所有需要添加到容器中的bean；调用
     *                               BeanDefinitionRegistry.registerBeanDefinition的方法自定义手工注册类
     */
    @Override
    public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) {

        boolean red = beanDefinitionRegistry.containsBeanDefinition(&quot;com.atguigu.bean.Red&quot;);
        boolean red2 = beanDefinitionRegistry.containsBeanDefinition(&quot;com.atguigu.bean.Blue&quot;);
        if (red&amp;&amp;red2){
            //指定bean定义信息
            RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(RainBow.class);
            //注册一个bean，指定bean名
            beanDefinitionRegistry.registerBeanDefinition(&quot;rainBow&quot;,rootBeanDefinition);
        }
    }
}
</code></pre>

<p>测试</p>

<pre><code class="language-java">@Test
public void test04() {
    AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MainConfig02.class);
    printBeans(annotationConfigApplicationContext);
    Blue bean = annotationConfigApplicationContext.getBean(Blue.class);
    System.out.println(bean);
}

private void printBeans(AnnotationConfigApplicationContext annotationConfigApplicationContext){
    String[] beanDefinitionNames = annotationConfigApplicationContext.getBeanDefinitionNames();
    for (String beanDefinitionName : beanDefinitionNames) {
        System.out.println(beanDefinitionName);
    }
}
</code></pre>

<p>4.实例</p>

<pre><code class="language-java">@Bean
public ColorFactoryBean colorFactoryBean(){
    return  new ColorFactoryBean();
}
</code></pre>

<pre><code class="language-java">//创建一个Spring的定义的FactoryBean
public class ColorFactoryBean implements FactoryBean&lt;Color&gt; {
   //返回一个Color对象，这个对象会添加到容器中
    @Override
    public Color getObject() throws Exception {
        System.out.println(&quot;ColorFactoryBean......&quot;);
        return new Color();
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return Color.class;
    }

    //是否是单例
    //true是单实例，在容器中保存一份
    //false是多实例，每次创建都会创建一个新的bean
    @Override
    public boolean isSingleton() {
        return false;
    }
}
</code></pre>

<p>测试</p>

<pre><code class="language-java">@Test
public void test05() {
    AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MainConfig02.class);
    printBeans(annotationConfigApplicationContext);
    Blue bean = annotationConfigApplicationContext.getBean(Blue.class);
    System.out.println(bean);

    //工厂bean获取的是调用getObject创建的对象
    Object colorFactoryBean = annotationConfigApplicationContext.getBean(&quot;colorFactoryBean&quot;);
    Object colorFactoryBean2 = annotationConfigApplicationContext.getBean(&quot;colorFactoryBean&quot;);
    System.out.println(&quot;bean的类型：&quot;+colorFactoryBean.getClass());
    System.out.println(colorFactoryBean==colorFactoryBean2);
    Object colorFactoryBean3 = annotationConfigApplicationContext.getBean(&quot;&amp;colorFactoryBean&quot;);
    System.out.println(colorFactoryBean3.getClass());
}
</code></pre>

<h5 id="9-bean的生命周期">9、bean的生命周期</h5>

<pre><code class="language-java">/**
 * bean的生命周期
 *  bean创建。。。。初始化。。。销毁过程
 *  容器管理bean的生命周期
 *  我们可以自定义初始化和销毁方法，容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁过程
 *构造（对象创建）
 *         单实例；在容器启动的时候创建对象
 *         多实例：在每次获取的时候创建对象
 *  1.指定初始化和销毁方法
 *      通过@Bean指定init-method=&quot;&quot; 和destroy-method=&quot;&quot;
 *  2.通过bean实现InitializingBean（定义初始化逻辑）
 *                  DisposableBean(定义销毁逻辑)
  *  3.可以使用JSR250
 *      @PostConstruct:在bean创建完成并且属性赋值完成，来执行初始化方法
 *      @PreDestroy：在容器销毁bean之前通知我们进行清理工作
 *  4、BeanPostProcessor【interface】:bean的后置处理器
 *          在bean初始化前后进行一些处理工作；
 *          postProcessBeforeInitialization：初始化之前
 *          postProcessAfterInitialization：初始化之后
 *   spring底层对BeanPostProcessor的使用：
 *          bean赋值，注入组件，@Autowired,生命周期注解功能，@Async,xxx
 
 * 初始化：
 *      对象创建完成，并赋值好，调用初始化方法
 * 销毁
 *      单实例：容器关闭的时候
 *      多实例：容器不会调用销毁方法
 */
@Configuration
public class MyConfigOfLifeCycle {

    //@Scope(&quot;prototype&quot;)
    @Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;detory&quot;)
    //相当于在xml中配置
   /* &lt;bean id=&quot;person&quot; class=&quot;com.atguigu.bean.Person&quot; 		scope=&quot;prototype&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
        &lt;property name=&quot;age&quot; value=&quot;19&quot;/&gt;
    &lt;/bean&gt; */
    public Car car(){
        return  new Car();
    }
}
</code></pre>

<pre><code class="language-java">public class Car {

    public Car(){
        System.out.println(&quot;car constructor&quot;);
    }

    public  void init(){
        System.out.println(&quot;car ... init&quot;);
    }

    public void  detory(){
        System.out.println(&quot;car ... detory&quot;);
    }

}
</code></pre>

<p>测试</p>

<pre><code class="language-java">public class IOCTest_LifeCycle {

    @Test
    public  void test01(){
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MyConfigOfLifeCycle.class);
        System.out.println(&quot;容器创建完成&quot;);

        annotationConfigApplicationContext.getBean(&quot;car&quot;);

        annotationConfigApplicationContext.close();
    }
}
</code></pre>

<p>第二种方式</p>

<pre><code>*  2.通过bean实现InitializingBean（定义初始化逻辑）
*                  DisposableBean(定义销毁逻辑)
</code></pre>

<pre><code class="language-java">@Component//加入容器
public class Cat implements InitializingBean, DisposableBean {

    public Cat() {
        System.out.println(&quot;cat constructor....&quot;);
    }

    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;cat.....destroy&quot;);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;cat.....afterPropertiesSet&quot;);
    }
}
</code></pre>

<pre><code class="language-java">@ComponentScan(&quot;com.atguigu.bean&quot;)//直接注入bean方式扫描包
@Configuration
public class MyConfigOfLifeCycle  {}
</code></pre>

<p>第三种方式：使用JSR250</p>

<pre><code class="language-java">@PostConstruct
public  void init(){
    System.out.println(&quot;dog ...   @PostConstruct&quot;);
}

@PreDestroy
public void  detory(){
    System.out.println(&quot;dog ...     @PreDestroy&quot;);
}
</code></pre>

<p>第四种方式：</p>

<pre><code class="language-java">/**
 * 后置处理器
 * 将后置处理器加入到容器中
 */
@Component
public class MyBeanPostProcessor implements BeanPostProcessor {

    @Override
     public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;postProcessBeforeInitialization--------&quot;+beanName+&quot;-------&quot;+bean);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;postProcessAfterInitialization-----&quot;+beanName+&quot;-------&quot;+bean);
        return bean;
    }
}
</code></pre>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
